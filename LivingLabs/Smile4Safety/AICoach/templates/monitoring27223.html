<!--
This version contains the monitoring of states having monitoringstate = true
and will be showing only the monitoring states
-->
{% extends "base.html" %}

{% block page_content %}

<!--csrftoken is not defined-->
{% csrf_token %}
<script>
const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;
</script>


<h1> Model Monitoring</h1>

<div x-data="{show:false}">
  <template x-if="show">
    <div>Show Data if true</div>
  </template>
  <button @click="show=!show">Click</button>
</div>



<div x-data="monitoringProgress">


    <!--Base Network Model-->
    <div>
        <template x-for="(progress,pindex) in curProgress" :key="pindex">
            <div>
                <hr>
                <!--Iteration <span x-text="pindex"></span>-->
                <template x-for="(prg,prgindex) in progress.progress" :key="prgindex">
                    <div  x-data="{curprg: prg, bstate:prg.from, stateclicked: prg.from, istostate:false}">
                        <table>
                            <tr>
                                <td>
                                    <div x-show="true"> <!--"!bstate.isinternal"-->
                                        <button id="bstate.id" x-text="bstate.name"  type="button"
                                            @click="console.log('WORKING ON CHANGING THE COLOR AND DATA');
                                                recordFromAction(curprg);"
                                            class="button button4"
                                            :class="{ 'bg-yellow-300': (bstate.monitoringstate && !bstate.complete),
                                                      'bg-green-500':  (bstate.monitoringstate && bstate.complete),
                                                      'bg-green-300' : (!bstate.monitoringstate && bstate.complete),
                                                      'bg-neutral-300': (!bstate.monitoringstate && !bstate.complete)}">
                                            <!--:disabled="!bstate.monitoringstate">-->
                                        </button>
                                    </div>
                                </td>
                            </tr>
                            <!--<tr>
                                <td>
                                    <div x-show="prg.showNextEntry">
                                        <button x-on:click="showNextEventBasedProgressElement(curprg,stateclicked,istostate)" class="btn btn-success"> Show Next </button>
                                    </div>
                               </td>
                           </tr>-->
                        </table>
                    </div>
                </template>
            </div>
        </template>
    </div>

    <!--Base Network Model-->
</div>


<!--{{ data}}-->


<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('monitoringProgress', () => ({
            id:0, //model id
            name:'',
            stateMatrix:[],

            //base Level Network
            individualBaseLevelOutConnections:[],  //this structure contains all individual outgoing connections without X1->X1. May also have X1-X2;X1->X3
            outgoingBaseLevelNetwork:[],        // this structure contains causal connection X1->X2,X3 and so on
            //Base Level
            incomingBaseLevelNetwork:[],        //this structure contains all individual incoming connections
            // Adaption Levels
             firstOrderLevelNetwork:[], // this structure contains the first order level network
             secondOrderLevelNetwork:[], //this structure contains the second order level network

            //progress structures, the main structure is identical except
            // this structure contains complete progress of network
            completeProgressOfNetwork:[],
            /* this structure contains current progress of network
            i.e., if a state is an initial state, or it is completed,
            or if all completed states are in the curProgress but still there are some states left as incomplete*/
            curProgress:[],

            language:'nl-NL',
            iteration:0,



            /////////////////////////////////////////////////////////////////
            // Event handlers

            showNextProgressElement(curprg){
                /* This function is called when user requests to show the next state.
                    it gets the next progress element based upon the clicked state.
                    1. curprg element is shown
                    2. get to elemets of the state, and populate the progress element accordingly
                    2.a. if the state is already in the current progress
                                then dont show but change the values accordingly.
                    2.b. if the element is null then dont show the next state but alert with 'process is completed'
                    2.c. TO-THINK: if state is an internal state, how will it go to the next state?

                    //this.completeProgressOfNetwork[this.iteration] = {progress: progress}
                */

                from_elem = curprg.from
                to_elems = curprg.to
                //if the element is already in  the progress skip it otherwise show

                //console.log('from_elem',from_elem,this.completeProgressOfNetwork)

                // calls the statusupdate function to update all the model values
                this.getStatusUpdate()
                //console.log('this.completeProgressOfNetwork[this.iteration]',this.completeProgressOfNetwork[this.iteration])



            },

            recordFromAction(curprg){
            /*
                    This function is called when a from element is clicked
                    Input: current progress (curprg) and state (bstate)
                    Assumptions: State is not an internal state.
                    Output: 1. State is considered to be completed.
                            2. Show other outgoing states which are not internal
                */
                //console.log('recordFromAction - before updation - base level network', this.incomingBaseLevelNetwork)

                console.log('current progress,state clicked',curprg);

                from_elem = curprg.from
                console.log('from_elem', from_elem);
                //1.a. set the state as completed
                // preliminary checks
                //1.a.a. if the state is already completed
                if(from_elem.complete)
                {
                    console.log('state is already completed')
                    return
                }
                //1.a.b. if all incoming connections are completed then make it true and update all matrices accordingly

                if(from_elem.initial_state)
                {
                    from_elem.complete = true;
                    //update all matrices accordingly
                    nextidx = this.incomingBaseLevelNetwork.findIndex(e => e.state.id === from_elem.id )
                    if (nextidx > -1)
                    {
                        this.incomingBaseLevelNetwork[nextidx].state.complete = true
                        //console.log('STATUS', this.incomingBaseLevelNetwork[nextidx].state.complete)
                    }


                }
                else
                {
                    //check the incoming connections status on the back end only.
                }


                //1.b. update the values of the current state
                this.sendStatusUpdate(from_elem)

                //2. Show other outgoing states which are not internal - also not present before
                this.showNextProgressElement(curprg)

            },

            async getStatusUpdate(){
            /*  This function is called to continously update the values from django view for all the states in the model
            */
                try {
                    let data_url = './getstatestatus/'  //dont forget the trailing slash
                    response = await axios.get(data_url);
                    //console.log('Before updation - data recieved',response.data)
                    rec_model_info = JSON.parse(response.data)    // model info received similar to the sent
                    console.log('Before updation - model information recieved',rec_model_info)

                    last_progress = rec_model_info.last_progress[this.iteration]
                    base_level = rec_model_info.base_level
                    first_level = rec_model_info.first_level
                    second_level = rec_model_info.second_level


                    //updation of matrices

                    this.incomingBaseLevelNetwork = base_level
                    this.firstOrderLevelNetwork = first_level
                    this.secondOrderLevelNetwork = second_level

                    curprg = this.completeProgressOfNetwork[this.iteration].progress
                    for(var i = 0; i < last_progress['progress'].length; i++)
                    {
                        from_elem = last_progress['progress'][i].from
                        //updation of status in completeProgressOfNetwork
                        curprg[i].from.complete = from_elem.complete
                        if(from_elem.complete)
                        {
                            //if it is not already in current progress then append it
                            idx = this.curProgress[this.iteration].progress.findIndex(e => e.from.id == from_elem.id)
                            if(idx < 0)
                                this.curProgress[this.iteration].progress.push(curprg[i])
                        }

                        //TODO: update fout status if there are to elemets in parallel
                        //updation of status


                    }


                    console.log('getStatusUpdate - updated matrices')
                    console.log('base level network', this.incomingBaseLevelNetwork)
                    console.log('first level network', this.firstOrderLevelNetwork)
                    console.log('second level network', this.secondOrderLevelNetwork)
                    console.log('progress', this.completeProgressOfNetwork)



                } catch (err) {
                    // Handle Error Here
                    console.error(err);
                }
            },



            updateStateValues(curstate,level,timestamp){
                /*This function updates the states values of the connections
                    input: state that has been updated
                    level:0/1/2
                    timestamp: current timestamp
                    if curstate is found it is initialized by certain value; otherwise last value is placed
                */

                //console.log('updateStateValues - curstate', curstate)
                if (level == 0)
                    arr = this.incomingBaseLevelNetwork
                else if (level == 1)
                    arr = this.firstOrderLevelNetwork
                else if (level == 2)
                    arr = this.secondOrderLevelNetwork

                for(var i = 0; i < arr.length; i++){
                    incomingstate = arr[i].state
                    values = incomingstate.values
                    if(incomingstate.id == curstate.id && curstate.complete)
                        curvalue = 1.0; //TODO: state.initvalue;
                    else
                        curvalue = incomingstate.values[incomingstate.values.length - 1].curvalue

                    //incomingstate.complete = curstate.complete
                    value = {curvalue:curvalue, timestamp:timestamp}
                    values.push(value)
                }
            },
            sendStatusUpdate(state){
            /* This function sends the data to django view to start simulation
               At the same time, it will get the values updated from the simulation results
            */

                //set the values for all three levels
                timestamp = this.getTime();
                this.updateStateValues(state,0,timestamp) //set the values for state at this.incomingBaseLevelNetwork
                this.updateStateValues(state,1,timestamp) //set the values for state at this.firstOrderLevelNetwork
                this.updateStateValues(state,2,timestamp) //set the values for state at this.firstOrderLevelNetwork

                console.log('Before sendStatusUpdate')
                console.log('base level network', this.incomingBaseLevelNetwork)
                console.log('first level network', this.firstOrderLevelNetwork)
                console.log('second level network', this.secondOrderLevelNetwork)
                console.log('progress', this.completeProgressOfNetwork)

                axios({
                method: 'post',
                url: '/setstatestatus/',
                data: {
                    id: this.id,
                    name: this.name,
                    base_level: this.incomingBaseLevelNetwork,
                    first_level: this.firstOrderLevelNetwork,
                    second_level: this.secondOrderLevelNetwork,
                    last_progress: this.completeProgressOfNetwork
                },
                headers: {//'Content-Type': 'application/json',
                           'X-CSRFToken': csrftoken},
                           validateStatus: (status) => {         //validateStatus
                           return true;
                          },
                })
                .then((response) => {
                    if (response.status == '200')
                    {
                        console.log(response.status);
                    }

                }, (error) => {
                    console.log(error.response.data);
                });
            },

            //////////////////////Supporting Methods

            getTime(){
            //This method returns curr time
                var currentdate = new Date();

                var timestamp = "" + currentdate.getFullYear() + "-"
                                   + (currentdate.getMonth()+1)  + "-"
                                   + currentdate.getDate() + "@"
                                   + currentdate.getHours() + ":"
                                   + currentdate.getMinutes() + ":"
                                   + currentdate.getSeconds();

                return timestamp
            },

            getToElementsofaState(state, produce = true){
                  /*
                  this function returns the to elements of a state
                  Input: state
                  Output: list of outgoing elements
                  1. get the outgoing elements of a state
                  2 will think. increment the iteration and
                  2. append the outgoing elements in the progress of network
                  */
                //console.log('PRODUCE',produce);
                progress = []
                nextidx = this.outgoingBaseLevelNetwork.findIndex(e => e.from.id === state.id )
                //console.log('state,nextidx',state,nextidx)
                if(nextidx > -1)
                {
                  //1. get the to elements of the 'from' state.
                  //1.a. get the outgoing elements of each of the to states
                  //1.b. append the outgoing elements in the progress of network

                  to_elems =  this.outgoingBaseLevelNetwork[nextidx].to
                  for(let i = 0; i < to_elems.length;i++)
                  {
                    from_state = to_elems[i]
                    idx = this.outgoingBaseLevelNetwork.findIndex(e => e.from.id === from_state.id )
                    //console.log('getToElementsofaState: from_state, idx =',from_state, idx)
                    if(idx > -1)
                    {

                        //create new entry and update its status
                        elem = this.outgoingBaseLevelNetwork[idx]
                        entry = this.createNewEntry(elem)
                        //console.log('entry =',entry,produce,this.iteration)

                        if(produce)
                        {
                            this.completeProgressOfNetwork[this.iteration].progress.push(entry)
                        }
                    }
                    else
                    {
                        //check if this is the last entry then show it as completed
                        console.log('getToElementsofaState: from_state', from_state)
                        if(from_state.id == '')
                        {

                            from = this.createNewElement(from_state)
                            //console.log('LASTTTTTTTTTTTT STATE:', from_state,produce)
                            //if last state is klaar, mark it as completed
                            from.complete = true
                            to = []
                            entry = {
                                from: from,
                                to: to
                            }

                            if(produce)
                                this.completeProgressOfNetwork[this.iteration].progress.push(entry)
                        }
                    }
                  }
                }
              return to_elems
            },

            createNewEntry(curprg){
                /*this function creates an entry with new elements in it.
                This takes an entry having from, to and shownext and showstates parameters
                Target is to keep each state independent*/

                from = this.createNewElement(curprg.from)
                to = this.generateToElements(curprg.to)
                //completed = this.updateStateStatus(from)
                //console.log('completed',completed)

                entry = {
                           from: from,
                           to: to
                       }
               return entry
            },


            /////////////////////////////////////////////////////////////////
            // Initializations

            init(){
                /* Loading the graph from the database*/
                //1. parse json
                 json_data = JSON.parse("{{data|escapejs}}")
                 //console.log(json_data)
                 this.id = this.id
                 this.name = json_data.name
                 specification = json_data.specification

                 baseModel = specification[0]
                 //this.firstOrderLevelNetwork = specification[1]
                 //this.secondOrderLevelNetwork = specification[2]

                 //2. generating stateMatrix
                 this.stateMatrix.push(specification[0])
                 this.stateMatrix.push(specification[1])
                 this.stateMatrix.push(specification[2])


                 //3.a generating model matrix. This matrix consists of incoming connections
                 //console.log(baseModel)
                 this.generateIncomingNetwork(specification[0],'base')
                 this.generateIncomingNetwork(specification[1],'first')
                 this.generateIncomingNetwork(specification[2],'second')

                 //3.b. generating model matrix. This matrix consists of outgoing connections
                 this.generateOutgoingBaseLevelNetwork(baseModel)




                 // 4. initialization of completeProgressOfNetwork
                 this.initializeProgress()

            },//init

            initializeProgress()
            {
                /* This function populates the network to be displayed for the initial states
                    It also allocates the memory for the network
                */

                progress = []
                initial_progress = []
                //populating the network with the initial states
                for (i = 0; i < this.outgoingBaseLevelNetwork.length; i++)
                {
                    curiterEntry = this.outgoingBaseLevelNetwork[i]
                    initial_state = curiterEntry.from.initial_state
                    console.log('initial_state',initial_state)
                    entry = this.createNewEntry(curiterEntry)
                    progress.push(entry)
                    if(initial_state)
                    {
                        initial_progress.push(entry)
                    }

                }
                this.completeProgressOfNetwork[this.iteration] = {progress}
                if(initial_progress.length > 0)
                {
                    progress = initial_progress
                    this.curProgress[this.iteration] = {progress}
                }

            },

            generateToElements(toelems){
                /* This function generates new progress Elements from the toelements
                Input: to elements
                Output: the 'to' states of the entry as 'new' elements => allocating new memory
                */

                to = []
                for(var i = 0; i < toelems.length; i++)
                {
                    to_elem = toelems[i]
                    elem = this.createNewElement(to_elem)
                    to.push(elem)
                }
                return to
            },




            //Outgoing Network Model

            generateOutgoingBaseLevelNetwork(model) {
                /*making the outgoing graph from individual incoming connections
                    Input: X1->X2 and X1->X3
                    Output: X1->X2,X3
                    This will populate outgoingBaseLevelNetwork which will have information like 'from' state to 'to' states
                 */

                this.generateIndividualBaseLevelOutConnections(model)

                // get outgoing states for all states in a model

                incomingGraph = []

                for (index = 0; index < this.individualBaseLevelOutConnections.length; index++)
                {
                    //generating from element
                    elem = this.individualBaseLevelOutConnections[index].from
                    //check if from_elem is an initial state
                    initial_state = this.isInitialState(elem)

                    from_elem = this.createNewElement(elem)
                    from_elem.initial_state = initial_state

                    //generating to elements
                    elem = this.individualBaseLevelOutConnections[index].to
                    initial_state = this.isInitialState(elem)
                    to_elem = this.createNewElement(elem)
                    to_elem.initial_state = initial_state
                    //console.log('to_elem', to_elems)

                    to_elems=[]

                    idx = this.outgoingBaseLevelNetwork.findIndex(e => e.from.id === from_elem.id)
                    console.log('idx,from_elem', idx, from_elem)

                    if(idx == -1)
                    {
                        //element is not found in the outgoingBaseLevelNetwork
                        //check if to_elem is already a from element then create a new element
                        toidx = this.outgoingBaseLevelNetwork.findIndex(e => e.from === to_elem)
                        //console.log('toidx', toidx)

                        if(toidx > -1)
                        {
                            elem = this.outgoingBaseLevelNetwork[toidx].from
                            initial_state = this.isInitialState(elem)
                            to_elem = this.createNewElement(elem)
                            to_elem.initial_state = initial_state
                        }

                        to_elems.push(to_elem)


                        this.outgoingBaseLevelNetwork.push({from: from_elem, to: to_elems})
                    }
                    else
                    {
                        //from state already exists in the network, then append the baseModel
                        this.outgoingBaseLevelNetwork[idx].to.push(to_elem)
                    }
                }




            }, //generateOutgoingBaseLevelNetwork

            generateIndividualBaseLevelOutConnections(model){
            /*  Function to extract the incoming states to make an outgoing graph
                Input: States like X2<-X1; X3<-X1
                Output: X1->X2 and X1->X3
                */

                for(var i = 0; i < model.states.length; i++){
                    state = model.states[i];
                    this.getOutgoingStates(state, model)
                }
           },

           getOutgoingStates(to_state, model){
            /*  Function to extract the incoming states to make an outgoing graph
                Input: States like X2<-X1; X3<-X1
                Output: X1->X2 and X1->X3
            */
                   sid = state.id.toLowerCase()
                   found = false
                   //console.log('states', model.states)
                   for(i = 0; i< model.states.length;i++)
                   {
                       incoming = model.states[i].inconnection
                       for(j = 0; j < incoming.length;j++)
                       {
                            val = incoming[j].value.toLowerCase()
                            if( val == sid)
                            {
                                found = true
                                ostate = model.states[i]
                                if(ostate != state) //avoiding self-reference
                                {
                                    this.individualBaseLevelOutConnections.push({'from':state, 'to':ostate})
                                }
                            }
                       }
                   }
                   //if (found)
                   if (!found)
                   {
                      toelem = this.createNewElement() //process completed
                      toelem.name = 'Klaar'
                      toelem.username = 'Klaar'

                      this.individualBaseLevelOutConnections.push({'from':state, 'to':toelem})
                   }
                   console.log('individual',this.individualBaseLevelOutConnections)
           },

           isInitialState(state)
           {
               //this function check and return if a state is an initial state
               initial = false
               //console.log('state',state)
              // console.log('incomingBaseLevelNetwork',this.incomingBaseLevelNetwork)
               idx = this.incomingBaseLevelNetwork.findIndex(e => e.state.id == state.id)
               if(idx > -1)
               {
                    incoming_elems = this.incomingBaseLevelNetwork[idx].incoming_states
                    //if there is no incoming element
                    if(incoming_elems[0].id == '')
                        return true

                    if (idx == 0)//Assumption: first state is always an initial state
                        initial = true
               }
               return initial
           },


            //Incoming Network Model

            generateIncomingNetwork(model,level){
                /*  Function to extract the incoming states to make an incoming graph
                Input: States like X1<-X1; X2<-X1
                Output: X1<-null and X2<->X1
                */

                   for(var i = 0; i < model.states.length; i++){
                      state = model.states[i]
                      if(level == 'base')
                      {
                          incoming_states = this.getIncomingStates(state,model)
                          this.incomingBaseLevelNetwork.push({state: state, incoming_states: incoming_states})
                      }
                      else if(level == 'first')
                      {
                        this.firstOrderLevelNetwork.push({state: state})
                      }
                      else if(level == 'second')
                      {
                        this.secondOrderLevelNetwork.push({state: state})
                      }
                   }
            },

            getIncomingStates(states,model){
                   /*   Function to extract the incoming states to make an incoming graph
                        Input: States like X2<-X1; X1<-X1
                        Output: X2->X1 and X1->0
                   */

                   sid = state.id.toLowerCase()

                   found = false
                   idx = model.states.findIndex(e => e.id.toLowerCase() == sid)
                   incoming = model.states[idx].inconnection
                   //iterate the incoming states data structure
                   incoming_states = []
                   for(var i = 0; i < incoming.length; i++){
                        conn_value = incoming[i].value.toLowerCase()
                        if(conn_value != sid) //avoiding self reference
                        {
                            found = true
                            incoming_stateidx = model.states.findIndex(e => e.id.toLowerCase() == conn_value)
                            incoming_state = model.states[incoming_stateidx]
                            incoming_states.push(incoming_state)
                        }
                   }

                   if(!found)
                   {
                     null_state = this.createNewElement()
                      incoming_states.push(null_state)
                   }

                   return incoming_states
          },

          //Creating a new element, to avoid replicas
          createNewElement(element){
              if(element)
              {
                    //convert strings if any to boolean
                    var complete = (element.complete === 'true');
                    isinternal = false
                    if(element.isinternal == 'true' || element.isinternal == true)
                        isinternal = true

                    elem = {
                    id: element.id,
                    name: element.name,
                    username: element.username,
                    combinationfunctions:element.combinationfunctions,
                    connectionweights: element.connectionweights,
                    inconnection: element.inconnection,
                    initvalue: element.initvalue,
                    showParamBtn: element.showParamBtn,
                    speed: element.speed,
                    message: element.message,
                    sentimentlbl: element.sentimentlbl,
                    complete: complete,
                    isinternal:element.isinternal,
                    values:element.values,
                    initial_state: element.initial_state,
                    fout: false
                    }

                    return elem
              }

              elem = {
                    id: '',
                    name: '',
                    username: '',
                    combinationfunctions:[],
                    connectionweights: [],
                    inconnection: [],
                    initvalue: 0,
                    showParamBtn: false,
                    speed: 0,
                    message: [],
                    sentimentlbl: 'Positive',
                    complete:false,
                    isinternal:false,
                    values:[],
                    initial_state:false,
                    fout: false
                }
                return elem
          },






            ////////////////////////END Of ALPINE STRUCTURE/////////////////
            ////////////////////////////////////////////////////////////////
        }))
    })
</script>



{% endblock %}