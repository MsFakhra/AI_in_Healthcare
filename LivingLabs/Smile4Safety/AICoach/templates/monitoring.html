<!--
State Behavior

1.	For the front-end:
a.	States with no incoming states are considered as Initial states. They will be shown on the interface, when the protocol execution is started.
b.	No mental state will be shown on the frontend (to the doctors)
c.	User is allowed to click a state if it is observed, and it is marked as ‘Observed’. State observation will be received from backend.
2.	For the backend – server side:
a.	A state receives data continuously and updates its values continuously.
b.	A state will be observed if it has a value (let’s say if value > 0.2)
c.	If state has a value (or observed), then it is shown on the interface.


Decisive Behaviors

If a causal state is leading to multiple states, then user has to decide to choose ‘Observed’ from them:
3.	For the front-end:
a.	When user is offered with multiple states which are observed, user marks any(one) of them as ‘Observed’. Then the rest of the states can be considered as not ‘Not Observed’
b.	Do we have to limit him to choose only one state as observed? I think not.
c.	A ‘Not Observed’ state cant lead to the ‘Observed’ state(s).
d.	If there are other states (along with ‘Not Observed’ state) leading to a state, still the process will continue.
e.	If the further state(s) are not observed, then they will not be shown on the interface
4.	For the backend:
a.	The state values for the observed states are taken into account after user clicks ‘Observed’, and for the rest of the states the value is set constant or 0 and marked as ‘Not Observed’
b.	If there is a ‘Not Observed’ state (i.e., value = 0), we skip the states that follow this particular state for the dynamics of data. what can be good 0 or constant?
-->
{% extends "base.html" %}

{% block page_content %}

<!--csrftoken is not defined-->
{% csrf_token %}
<script>
const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;
</script>


<h1> Model Monitoring</h1>

<div class="two-columns-grid" x-data="monitoringProgress" x-init="startTimer();">
<div>
    <!--Base Network Model-->
    <div>
        <template x-for="(progress,pindex) in curProgress" :key="pindex">
            <div>
                <!--Iteration <span x-text="pindex"></span>-->
                <template x-for="(prg,prgindex) in progress.cur_progress" :key="prgindex">
                    <div  x-data="{cur_prg: prg, bstate:prg.from, stateclicked: prg.from, istostate:false}">
                        <table>
                            <tr>
                                <td>
                                    <div x-show="true"> <!--"!bstate.is_internal"-->
                                        <button id="bstate.id" x-text="bstate.id+':'+bstate.name"  type="button"
                                            @click="recordFromAction(cur_prg);"
                                            class="button button4"
                                            :class="{ 'bg-green-500':  (bstate.completed)}">
                                            <!--:disabled="!bstate.monitoringstate">-->
                                        </button>
                                    </div>
                                </td>
                            </tr>
                            <!--<tr>
                                <td>
                                    <div x-show="prg.showNextEntry">
                                        <button x-on:click="showNextEventBasedProgressElement(cur_prg,stateclicked,istostate)" class="btn btn-success"> Show Next </button>
                                    </div>
                               </td>
                           </tr>-->
                        </table>
                    </div>
                </template>
            </div>
        </template>
    </div>

    <!--Base Network Model-->
</div>


    <div>
    <h1>Status and Log</h1>
    <p>
        <!--<span x-text="status_log"></span>-->
        <span x-html="status_log.replaceAll('\n', '<br>')"></span>
    </p>
    </div>
</div>
<!--{{ data}}-->


<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('monitoringProgress', () => ({
            id:0, //model id
            name:'',
            stateMatrix:[],

            //base Level Network
            individualBaseLevelOutConnections:[],  //this structure contains all individual outgoing connections without X1->X1. May also have X1-X2;X1->X3
            outgoingBaseLevelNetwork:[],        // this structure contains causal connection X1->X2,X3 and so on
            //Base Level
            incomingBaseLevelNetwork:[],        //this structure contains all individual incoming connections
            // Adaption Levels
             firstOrderLevelNetwork:[], // this structure contains the first order level network
             secondOrderLevelNetwork:[], //this structure contains the second order level network

            //progress structures, please note, that the main structure is identical to the leveled architecture
            // this structure contains complete progress of network
            completeProgressOfNetwork:[],
            /* this structure contains current progress of network
            i.e., if a state is an initial state, or it is completed*/
            curProgress:[],
            /* this structure contains remaining progress of network
            i.e., if all observed states are in the curProgress then it contains the states left as inobserved*/
            remProgress:[],

            language:'nl-NL',
            iteration:0,
            goTimer:true,  // should the timer method be called?
            status_log:'Welcome!  \n ', // this contains a string which will contain all the messages to speak and record



            /////////////////////////////////////////////////////////////////
            // Event handlers

            recordFromAction(cur_prg){
            /*
                    This function is called when a from element is clicked. Functionality is implemented for the for elements of the element cur_prg.
                    Input: current progress (cur_prg) and state (bstate)
                    Pre-Processing: States shown are not internal states. The states are either
                        1. initial states, or
                        2. observed states
                    Processing:
                        1. state is marked as completed, if it is not completed before and it is initial state
                        2. if 1 is not satisfied then all incoming connections are checked for completion and then it is marked as completed

                    Output: 1. State is marked as completed.
                            2. Audio is played for the status
                */

                from_elem = cur_prg.from
                //1.a. set the state as completed
                // preliminary checks
                //1.a.a. if the state is already observedd

                if(from_elem.completed)
                {
                    this.status_log = 'Taak is al als voltooid gemarkeerd \n'
                    this.playPositiveTone(this.status_log)
                    return
                }
                //1.a.b. if the state is an initial state then it is marked as completed and observed
                if(from_elem.initial_state)
                {
                   from_elem.observed = true
                   from_elem.completed = true
                   idx = this.incomingBaseLevelNetwork.findIndex(e => e.state.id === from_elem.id)
                   if(idx > -1)
                   {
                        this.incomingBaseLevelNetwork[idx].state.observed = true
                        this.incomingBaseLevelNetwork[idx].state.completed = true
                   }
                   this.status_log = 'Je hebt zojuist' + from_elem.name + ' afgerond\n'
                   this.playPositiveTone(this.status_log)
                }
                else
                {
                   incoming_status = this.isIncomingComplete(from_elem)
                   //console.log('incoming_status',from_elem, incoming_status)
                   //then state is marked as complete otherwise it is checked for loops and notifications are sent
                    //if incoming status is completed from all states (i.e., final_status == true)

                    final_status = false

                    if(incoming_status.length > 0)
                    {
                           idx = incoming_status.findIndex(e => e.completed == false)
                            if(idx > -1)
                                final_status = false
                            else
                                final_status = true
                    }


                   //console.log('final_status',final_status)
                   if(final_status == true)
                   {
                      from_elem.completed = true
                      this.status_log = 'Je hebt zojuist ' + from_elem.name + ' afgerond \n'
                      this.playPositiveTone(this.status_log)
                   }
                   else
                   {
                      //state is checked for loops and notifications are sent
                      this.status_log = ''

                      //loop_incomplete is for self referencing,
                      //if there is a loop, then it makes the from element complete otherwise check for notifications
                      loop_incomplete = []
                      incomplete = []
                      for(var i = 0; i < incoming_status.length; i++)
                      {
                        //if(incoming_status[i].is_complete == false)
                        if(incoming_status[i].completed == false)
                        {
                            //if there is a loop, then it makes the from element complete
                            isloop = this.checkforLoop(incoming_status[i],from_elem)
                            //console.log('isloop',isloop,incoming_status[i],from_elem)
                            if(isloop == true)
                            {
                                loop_incomplete.push(incoming_status[i])
                            }
                            else
                            {
                                incomplete.push(incoming_status[i])
                            }
                        }
                      }
                      //check if the rest of the states are complete then make it complete
                      if(loop_incomplete.length > 0 && incomplete.length == 0)
                      {
                        from_elem.completed = true
                        console.log('from_elem',from_elem)
                        this.status_log = 'Je hebt zojuist ' + from_elem.name + ' afgerond. \n'
                        this.playPositiveTone(this.status_log)
                      }
                      else
                      {
                        for(var i = 0; i < incomplete.length; i++)
                        {
                            this.status_log = this.status_log + ' ' + incomplete[i].name
                                              + ' is nog niet compleet. \n'
                        }
                        if(incomplete.length == 1)
                            this.status_log = this.status_log + 'Ben je vergeten op de staat te klikken? \n'
                        else
                            this.status_log = this.status_log + 'Ben je vergeten op de staten te klikken? \n'
                        this.playNegativeTone(this.status_log)
                      }
                   }
                }

                console.log('status_log: ',this.status_log)


            },

            //////////////////////////supporting methods
            playNegativeTone(message){
                //This method is used to change pitch
                pitch = 0.9
                rate = 0.7
                this.play(message,pitch,rate)
            },

            playPositiveTone(message){
                //This method is used to change pitch
                pitch = 0.8
                rate = 0.85
                this.play(message,pitch,rate)
            },
            play(str, pitch,rate){
                        /*Text to speech
                link used: https://usefulangle.com/post/98/javascript-text-to-speech
            */
              //return
              console.log('pitch',pitch);
              if ('speechSynthesis' in window) {
                let speech = new SpeechSynthesisUtterance(str);
                speech.lang = this.language;
                speech.pitch = pitch;
                speech.rate = rate;

                window.speechSynthesis.speak(speech);
              }
              else{
                document.write("Browser not supported")
              }
              //this.sleep(10000)
              return
            },

            sleep(ms)
            {
                //function used to put delay
                var start = new Date().getTime();
                for (var i = 0; i < 1e7; i++) {
                 if ((new Date().getTime() - start) > ms){
                   break;
                 }
               }
            },

            checkforLoop(stateinfo,from_elem){
                //This function checks for loop, and returns true or false

                console.log('stateinfo', stateinfo)
                in_connection = stateinfo.in_connection
                idx = in_connection.findIndex(e => e.value == from_elem.id)
                if(idx > -1)
                    return true
                else
                    return false
            },
            startTimer() {
            /* This function will recieve the data from backend continously, untill the whole protocol is completed*/

            setInterval(() => {
                 if (this.goTimer == true) {
                     this.getStatusUpdate()
                    }
                }, 10000);
            },

            isIncomingComplete(from_elem)
            {   //TO-DO: Check Incoming Connections
                /*  This function checks all incoming states,
                    if all states are completed. It returns a structure with state name and status.
                */

                index = this.incomingBaseLevelNetwork.findIndex(e => e.state.id == from_elem.id)
                if(index < 0)
                    return false

                final_status = false
                cur_status = []
                incoming_ids = this.incomingBaseLevelNetwork[index].state.in_connection
                for (var i = 0; i < incoming_ids.length; i++){
                    id_value = incoming_ids[i].value
                    //ignore self-referencing
                    if(id_value != from_elem.id){
                        //check if the incoming state is observed
                        //Either it is present in currProgress, or it is present in incomingBaseLevelNetwork
                        pidx = this.curProgress[this.iteration].cur_progress.findIndex(e => e.from.id === id_value)
                        if(pidx > -1){
                            //state is found. Save status
                            state = this.curProgress[this.iteration].cur_progress[pidx]
                            //cur_status.push({state_id: state.from.id, state_name:state.from.name, is_complete: state.from.completed})
                            cur_status.push(state.from)
                        }
                        else
                        {
                            //check incomingBaseLevelNetwork for inner states and higher level states
                            iidx = this.incomingBaseLevelNetwork.findIndex(e => e.state.id == id_value)
                            if(iidx > -1)
                            {
                                //console.log('this.incomingBaseLevelNetwork',this.incomingBaseLevelNetwork[iidx])
                                state = this.incomingBaseLevelNetwork[iidx].state
                                //cur_status.push({state_id: state.id, state_name:state.name, is_complete: state.completed})
                                cur_status.push(state)
                            }
                        }
                    }
                }

                return cur_status
            },

            //async
            sendStatusUpdate(){
            /* This function sends the data to django view to start simulation
               Algorithm:
                1. update values for every state.
                2. once they are updated, then send to server
            */


                //1. update the values for all three levels
                time_stamp = this.getTime();

                for(var i = 0; i < this.incomingBaseLevelNetwork.length > 0; i++)
                {
                    incomingstate = this.incomingBaseLevelNetwork[i].state

                    //Update the current progress
                    idx = this.curProgress[this.iteration].cur_progress.findIndex(e => e.from.id == incomingstate.id && e.from.completed == true)
                    if(idx > -1)
                    {
                        if(this.curProgress[this.iteration].cur_progress[idx].from.completed)
                        {
                            this.curProgress[this.iteration].cur_progress[idx].from.observed = true
                            incomingstate.observed = true
                            incomingstate.completed = true
                        }
                    }
                    values = incomingstate.values
                    //TO-DO: Do I need to use this except for the last value?
                    if(values.length > 1)   //at index 0 there is no value; used for structure only //pick the last element
                    {
                        cur_value = incomingstate.values[incomingstate.values.length - 1].cur_value
                        //console.log('Last value',incomingstate,cur_value)
                    }
                    else
                    {
                        cur_value = parseFloat(incomingstate.init_value)
                        incomingstate.values[incomingstate.values.length - 1].cur_value = cur_value
                        incomingstate.values[incomingstate.values.length - 1].time_stamp = time_stamp
                    }


                }

                //updating firstOrderNetwork
                for(var i = 0; i < this.firstOrderLevelNetwork.length > 0; i++)
                {
                    incomingstate = this.firstOrderLevelNetwork[i].state
                    //console.log('incomingstate',incomingstate)
                    values = incomingstate.values
                    if(values.length > 1)   //at index 0 there is no value; used for structure only //pick the last element
                    {
                        cur_value = incomingstate.values[incomingstate.values.length - 1].cur_value
                    }
                    else
                    {
                        cur_value = parseFloat(incomingstate.init_value)
                        incomingstate.values[incomingstate.values.length - 1].cur_value = cur_value
                        incomingstate.values[incomingstate.values.length - 1].time_stamp = time_stamp
                    }
                }

                //updating secondOrderNetwork
                for(var i = 0; i < this.secondOrderLevelNetwork.length > 0; i++)
                {
                    incomingstate = this.secondOrderLevelNetwork[i].state
                    values = incomingstate.values
                    //console.log('values.length',values.length)
                    if(values.length > 1)   //at index 0 there is no value; used for structure only //pick the last element
                    {
                        cur_value = incomingstate.values[incomingstate.values.length - 1].cur_value

                    }
                    else
                    {
                        cur_value = parseFloat(incomingstate.init_value)
                        incomingstate.values[incomingstate.values.length - 1].cur_value = cur_value
                        incomingstate.values[incomingstate.values.length - 1].time_stamp = time_stamp
                    }
                }




                for (var i = 0; i < this.completeProgressOfNetwork[this.iteration].progress.length; i++)
                {
                    from_elem = this.completeProgressOfNetwork[this.iteration].progress[i].from

                    idx = this.curProgress[this.iteration].cur_progress.findIndex(e => e.from.id == from_elem.id && e.from.completed == true)
                    if(idx > -1)
                    {
                        from_elem.observed = true
                        from_elem.completed = true
                    }

                    values = from_elem.values
                    if(values.length > 1)
                    {
                        cur_value = incomingstate.values[incomingstate.values.length - 1].cur_value
                    }
                    else
                    {
                        cur_value = parseFloat(incomingstate.init_value)
                        incomingstate.values[incomingstate.values.length - 1].cur_value = cur_value
                        incomingstate.values[incomingstate.values.length - 1].time_stamp = time_stamp
                    }
                }


                out_data = {
                    id: this.id,
                    name: this.name,
                    base_level: this.incomingBaseLevelNetwork,
                    first_level: this.firstOrderLevelNetwork,
                    second_level: this.secondOrderLevelNetwork,
                    last_progress: this.completeProgressOfNetwork
                }

                console.log('Before sendStatusUpdate')
                console.log('sending data to server', out_data)

                axios({
                method: 'post',
                url: '/setcurrentstatus/',
                data: {
                    id: this.id,
                    name: this.name,
                    base_level: this.incomingBaseLevelNetwork,
                    first_level: this.firstOrderLevelNetwork,
                    second_level: this.secondOrderLevelNetwork,
                    last_progress: this.completeProgressOfNetwork,
                    cur_progress: this.curProgress
                },
                headers: {//'Content-Type': 'application/json',
                           'X-CSRFToken': csrftoken},
                           validateStatus: (status) => {         //validateStatus
                           return true;
                          },
                })
                .then((response) => {
                    if (response.status == '200')
                    {
                        console.log(response.status);
                    }

                }, (error) => {
                    console.log(error.response.data);
                });
            },

            async getStatusUpdate(){
            /*  This function is called to to update the values from django view for all the states in the model
                Algorithm:
                    1. If one of the shown states is clicked then it starts to get the values, otherwise it doesn't get the values
                    2. first it sends the current data to the server, and then it receives the data
            */

                //console.log("status update called")
                idx = this.curProgress[this.iteration].cur_progress.findIndex(e => e.from.observed == true)
                //1. It doesn't proceed if there is no state clicked at all
                if(idx <= -1)
                   return

                this.sendStatusUpdate()


                try {
                    let data_url = './getstatestatus/'  //dont forget the trailing slash
                    response = await axios.get(data_url);
                    //console.log('Before updation - data recieved',response.data)
                    rec_model_info = JSON.parse(response.data)    // model info received similar to the sent
                    console.log('Before updation - model information recieved',rec_model_info)

                    r_last_progress = rec_model_info.last_progress[this.iteration]
                    base_level = rec_model_info.base_level
                    first_level = rec_model_info.first_level
                    second_level = rec_model_info.second_level




                    //updation of matrices

                    this.incomingBaseLevelNetwork = base_level
                    this.firstOrderLevelNetwork = first_level
                    this.secondOrderLevelNetwork = second_level

                    //console.log('After updation - BaseLevel',this.incomingBaseLevelNetwork)
                    //console.log('After updation - First Level',this.firstOrderLevelNetwork)
                    //console.log('After updation - Second Level',this.secondOrderLevelNetwork)


                    //WORKING HERE
                    //// values sent are done, recieving in incoming base level
                    //simulation is working
                    //matrices are updating, now have to work on curprg

                    complete_prg = this.completeProgressOfNetwork[this.iteration].progress

                    //console.log('last_progress',r_last_progress)
                    //console.log('complete_prg',complete_prg)
                    //console.log('this.curProgress[this.iteration]',this.curProgress[this.iteration])

                    for(var i = 0; i < r_last_progress['progress'].length; i++)
                    {
                        from_elem = r_last_progress['progress'][i].from
                        //console.log('from_elem',from_elem)
                        //updation of status in currentProgress
                        complete_prg[i].from.observed = from_elem.observed


                        //if element is not complete but is observed in the software, update current progress to include it
                        if(!from_elem.completed && from_elem.observed)
                        {
                            //If element is not already in the curProgress then add the element to the current progress
                            this.updateProgress(from_elem,complete_prg)
                        }

                        //still, if all incoming elements are completed then show element in progress

                        incoming_status = this.isIncomingComplete(from_elem)
                        //console.log('incoming_status',from_elem.name,incoming_status)

                       if(incoming_status.length > 0)
                       {
                           iidx = incoming_status.findIndex(e => e.completed == false)
                            if(iidx < 0)
                                this.updateProgress(from_elem,complete_prg)
                       }








                        //TODO: update fout status if there are to elemets in parallel
                        //updation of status


                    }


                    //console.log('getStatusUpdate - updated matrices')
                    //console.log('base level network', this.incomingBaseLevelNetwork)
                    //console.log('first level network', this.firstOrderLevelNetwork)
                    //console.log('second level network', this.secondOrderLevelNetwork)
                    //console.log('progress', this.completeProgressOfNetwork)



                } catch (err) {
                    // Handle Error Here
                    console.error(err);
                }
            },

            updateProgress(from_elem, complete_prg){
                    /*
                        if element is not an internal state, and not already in current progress then append it in curProgress and remove from remaining progress.
                        if element is an internal state, then just complete it
                        if the element is an internal state then also complete the incomingBaseLevelNetwork
                    */

                    if(from_elem)
                        if(!from_elem.is_internal)
                        {
                            idx = this.curProgress[this.iteration].cur_progress.findIndex(e => e.from.id == from_elem.id)
                            //console.log('CURRR idx',idx, this.curProgress[this.iteration].cur_progress)
                            if(idx < 0)
                            {
                                //check the element from complete progress
                                cidx = complete_prg.findIndex(e => e.from.id == from_elem.id)
                                if(cidx > -1)
                                {
                                    this.curProgress[this.iteration].cur_progress.push(complete_prg[cidx])
                                }

                                //if it is in current progress then remove it from remaining progress
                                ridx = this.remProgress[this.iteration].rem_progress.findIndex(e => e.from.id == from_elem.id)
                                //console.log('REM idx',ridx, this.remProgress[this.iteration].rem_progress)
                                if(ridx > -1)
                                {
                                    elem = this.remProgress[this.iteration].rem_progress[ridx]
                                    this.remProgress[this.iteration].rem_progress.splice(ridx, 1)  // remove one element only
                                    //console.log("removed element",elem,this.remProgress[this.iteration].rem_progress)
                                }
                            }
                        }
                        else
                        {
                            //update progress and incomingBaseLevelNetwork
                            cidx = complete_prg.findIndex(e => e.from.id == from_elem.id)
                            if(cidx > -1)
                            {
                               complete_prg[cidx].from.completed = true
                               this.incomingBaseLevelNetwork[cidx].state.completed = true
                            }


                        }
            },


            getTime(){
            //This method returns curr time
                var currentdate = new Date();

                var time_stamp = "" + currentdate.getFullYear() + "-"
                                   + (currentdate.getMonth()+1)  + "-"
                                   + currentdate.getDate() + "@"
                                   + currentdate.getHours() + ":"
                                   + currentdate.getMinutes() + ":"
                                   + currentdate.getSeconds();

                return time_stamp
            },

            //////////////////////Supporting Methods


            getToElementsofaState(state_id){
                  /*
                  this function returns the to elements of a state
                  Input: state
                  Output: list of outgoing elements
                  1. get the outgoing elements of a state
                  2 will think. increment the iteration and
                  2. append the outgoing elements in the progress of network
                  */
                //console.log('PRODUCE',produce);
                progress = []
                nextidx = this.outgoingBaseLevelNetwork.findIndex(e => e.from.id === state_id )
                //console.log('state,nextidx',state,nextidx)
                if(nextidx > -1)
                {
                  //1. get the to elements of the 'from' state.
                  //1.a. get the outgoing elements of each of the to states
                  //1.b. append the outgoing elements in the progress of network

                  to_elems =  this.outgoingBaseLevelNetwork[nextidx].to
                  for(let i = 0; i < to_elems.length;i++)
                  {
                    from_state = to_elems[i]
                    idx = this.outgoingBaseLevelNetwork.findIndex(e => e.from.id === from_state.id )
                    //console.log('getToElementsofaState: from_state, idx =',from_state, idx)
                    if(idx > -1)
                    {

                        //create new entry and update its status
                        elem = this.outgoingBaseLevelNetwork[idx]
                        entry = this.createNewEntry(elem)

                    }
                    else
                    {
                        //check if this is the last entry then show it as observedd
                        //console.log('getToElementsofaState: from_state', from_state)
                        if(from_state.id == '')
                        {

                            from = this.createNewElement(from_state)

                            //if last state is klaar, mark it as observedd
                            from.observed = true
                            from.completed = true
                            to = []
                            entry = {
                                from: from,
                                to: to
                            }
                        }
                    }
                  }
                }
              return to_elems
            },

            createNewEntry(cur_prg){
                /*this function creates an entry with new elements in it.
                This takes an entry having from, to and shownext and showstates parameters
                Target is to keep each state independent*/

                from = this.createNewElement(cur_prg.from)
                to = this.generateToElements(cur_prg.to)
                //observedd = this.updateStateStatus(from)
                //console.log('observedd',observedd)

                entry = {
                           from: from,
                           to: to
                       }
               return entry
            },


            /////////////////////////////////////////////////////////////////
            // Initializations

            init(){
                /* Loading the graph from the database*/
                //1. parse json
                 json_data = JSON.parse("{{data|escapejs}}")
                 //console.log(json_data)
                 this.id = this.id
                 this.name = json_data.name
                 specification = json_data.specification

                 baseModel = specification[0]
                 //this.firstOrderLevelNetwork = specification[1]
                 //this.secondOrderLevelNetwork = specification[2]

                 //2. generating stateMatrix
                 this.stateMatrix.push(specification[0])
                 this.stateMatrix.push(specification[1])
                 this.stateMatrix.push(specification[2])


                 //3.a generating model matrix. This matrix consists of incoming connections
                 //console.log(baseModel)
                 this.generateIncomingNetwork(specification[0],'base')
                 this.generateIncomingNetwork(specification[1],'first')
                 this.generateIncomingNetwork(specification[2],'second')

                 //3.b. generating model matrix. This matrix consists of outgoing connections
                 this.generateOutgoingBaseLevelNetwork(baseModel)

                 // 4. initialization of completeProgressOfNetwork
                 this.initializeProgress()
            },//init

            initializeProgress()
            {
                /* This function populates the network to be displayed for the initial states
                    It also allocates the memory for the progress network.
                    It does not include the initial states
                */

                progress = []
                cur_progress = []
                rem_progress = []
                //populating the network with the initial states
                //console.log('this.outgoingBaseLevelNetwork', this.outgoingBaseLevelNetwork)
                for (i = 0; i < this.outgoingBaseLevelNetwork.length; i++)
                {
                    curiterEntry = this.outgoingBaseLevelNetwork[i]
                    from_elem = curiterEntry.from
                    initial_state = from_elem.initial_state
                    is_internal = from_elem.is_internal
                    //console.log('initial_state, is_internal', initial_state, is_internal, from_elem.name)
                    entry = this.createNewEntry(curiterEntry)
                    progress.push(entry)
                    if(initial_state)
                    {
                        if(is_internal == false)
                            cur_progress.push(entry)
                    }
                    else
                    {
                        if(is_internal == false)
                            rem_progress.push(entry)
                    }


                }
                //console.log('progresses: complete progress',progress)
                //console.log('progresses: current progress',cur_progress)
                //console.log('progresses: remaining progress',rem_progress)

                this.completeProgressOfNetwork[this.iteration] = {progress}
                if(cur_progress.length > 0)
                {
                    this.curProgress[this.iteration] = {cur_progress}
                    this.remProgress[this.iteration] = {rem_progress}
                }

            },

            generateToElements(toelems){
                /* This function generates new progress Elements from the toelements
                Input: to elements
                Output: the 'to' states of the entry as 'new' elements => allocating new memory
                */

                to = []
                for(var i = 0; i < toelems.length; i++)
                {
                    to_elem = toelems[i]
                    elem = this.createNewElement(to_elem)
                    to.push(elem)
                }
                return to
            },




            //Outgoing Network Model

            generateOutgoingBaseLevelNetwork(model) {
                /*making the outgoing graph from individual incoming connections
                    Input: X1->X2 and X1->X3
                    Output: X1->X2,X3
                    This will populate outgoingBaseLevelNetwork which will have information like 'from' state to 'to' states
                 */

                this.generateIndividualBaseLevelOutConnections(model)

                // get outgoing states for all states in a model

                incomingGraph = []


                for (index = 0; index < this.individualBaseLevelOutConnections.length; index++)
                {
                    //generating from element
                    elem = this.individualBaseLevelOutConnections[index].from
                    //check if from_elem is an initial state
                    initial_state = this.isInitialState(elem)

                    from_elem = this.createNewElement(elem)

                    //setting as initial state status
                    from_elem.initial_state = initial_state
                    inc_idx = this.incomingBaseLevelNetwork.findIndex(e => e.state.id == from_elem.id)
                    if(inc_idx > -1)
                    {
                        this.incomingBaseLevelNetwork[inc_idx].state.initial_state = initial_state
                    }


                    //generating to elements
                    elem = this.individualBaseLevelOutConnections[index].to
                    initial_state = this.isInitialState(elem)
                    to_elem = this.createNewElement(elem)
                    to_elem.initial_state = initial_state
                    //console.log('to_elem', to_elems)

                    to_elems=[]

                    idx = this.outgoingBaseLevelNetwork.findIndex(e => e.from.id === from_elem.id)
                    //console.log('idx,from_elem', idx, from_elem)

                    if(idx == -1)
                    {
                        //element is not found in the outgoingBaseLevelNetwork
                        //check if to_elem is already a from element then create a new element
                        toidx = this.outgoingBaseLevelNetwork.findIndex(e => e.from === to_elem)
                        //console.log('toidx', toidx)

                        if(toidx > -1)
                        {
                            elem = this.outgoingBaseLevelNetwork[toidx].from
                            initial_state = this.isInitialState(elem)
                            to_elem = this.createNewElement(elem)
                            to_elem.initial_state = initial_state
                        }

                        to_elems.push(to_elem)


                        this.outgoingBaseLevelNetwork.push({from: from_elem, to: to_elems})
                    }
                    else
                    {
                        //from state already exists in the network, then append the baseModel
                        this.outgoingBaseLevelNetwork[idx].to.push(to_elem)
                    }
                }




            }, //generateOutgoingBaseLevelNetwork

            generateIndividualBaseLevelOutConnections(model){
            /*  Function to extract the incoming states to make an outgoing graph
                Input: States like X2<-X1; X3<-X1
                Output: X1->X2 and X1->X3
                */
                //console.log('states', model.states)
                for(var i = 0; i < model.states.length; i++){
                    state = model.states[i];
                    //console.log('state', state)
                    this.getOutgoingStates(state, model)
                }
           },

           getOutgoingStates(state, model){
            /*  Function to extract the incoming states to make an outgoing graph
                Input: States like X2<-X1; X3<-X1
                Output: X1->X2 and X1->X3
            */
                   sid = state.id.toLowerCase()
                   //console.log('state id',sid)
                   found = false
                   //console.log('states', model.states)
                   for(i = 0; i< model.states.length;i++)
                   {
                       incoming = model.states[i].in_connection
                       for(j = 0; j < incoming.length;j++)
                       {
                            ostate = model.states[i]
                            val = incoming[j].value.toLowerCase()
                            //console.log('ostate',ostate,val)
                            if( val == sid)
                            {
                                found = true
                                ostateid = ostate.id.toLowerCase()
                                //console.log('found',found,ostate,sid)
                                if(ostate != sid) //avoiding self-reference
                                {
                                    this.individualBaseLevelOutConnections.push({'from':state, 'to':ostate})
                                }
                            }
                       }

                   }
                   if (!found)
                   {
                      toelem = this.createNewElement() //process completed
                      toelem.name = 'Klaar'
                      toelem.user_name = 'Klaar'

                      this.individualBaseLevelOutConnections.push({'from':state, 'to':toelem})
                   }

                   //console.log('individual',this.individualBaseLevelOutConnections)
           },

           isInitialState(state)
           {
               //this function check and return if a state is an initial state
               initial = false
               //console.log('state',state)
              // console.log('incomingBaseLevelNetwork',this.incomingBaseLevelNetwork)
               idx = this.incomingBaseLevelNetwork.findIndex(e => e.state.id == state.id)
               if(idx > -1)
               {
                    incoming_elems = this.incomingBaseLevelNetwork[idx].incoming_states
                    //if there is no incoming element
                    if(incoming_elems[0].id == '')
                        return true

                    if (idx == 0)//Assumption: first state is always an initial state
                        initial = true
               }
               return initial
           },


            //Incoming Network Model

            generateIncomingNetwork(model,level){
                /*  Function to extract the incoming states to make an incoming graph
                Input: States like X1<-X1; X2<-X1
                Output: X1<-null and X2<->X1
                */

                   for(var i = 0; i < model.states.length; i++){
                      state = model.states[i]
                      state = this.createNewElement(state)
                      if(level == 'base')
                      {
                          incoming_states = this.getIncomingStates(state,model)
                          this.incomingBaseLevelNetwork.push({state: state, incoming_states: incoming_states})
                      }
                      else if(level == 'first')
                      {
                        state.completed = true
                        this.firstOrderLevelNetwork.push({state: state})
                      }
                      else if(level == 'second')
                      {
                        state.completed = true
                        this.secondOrderLevelNetwork.push({state: state})
                      }
                   }
            },

            getIncomingStates(states,model){
                   /*   Function to extract the incoming states to make an incoming graph
                        Input: States like X2<-X1; X1<-X1
                        Output: X2->X1 and X1->0
                   */

                   sid = state.id.toLowerCase()

                   found = false
                   idx = model.states.findIndex(e => e.id.toLowerCase() == sid)
                   incoming = model.states[idx].in_connection
                   //iterate the incoming states data structure
                   incoming_states = []
                   for(var i = 0; i < incoming.length; i++){
                        conn_value = incoming[i].value.toLowerCase()
                        if(conn_value != sid) //avoiding self reference
                        {
                            found = true
                            incoming_stateidx = model.states.findIndex(e => e.id.toLowerCase() == conn_value)
                            incoming_state = model.states[incoming_stateidx]
                            incoming_state = this.createNewElement(incoming_state)
                            incoming_states.push(incoming_state)
                        }
                   }

                   if(!found)
                   {
                     null_state = this.createNewElement()
                      incoming_states.push(null_state)
                   }

                   return incoming_states
          },

          adjustConnectionWeights(connection_weights){
            //This function is used to set the connection weights as absolute values

            //console.log('weights',connection_weights)
            for(var i = 0; i < connection_weights.length; i++)
            {
                if(connection_weights[i].value < 0)
                {
                    connection_weights[i].value = Math.abs(connection_weights[i].value)
                }
            }
            return connection_weights
          },

          //Creating a new element, to avoid replicas
          createNewElement(element){
              if(element)
              {
                    //convert strings if any to boolean
                    var completed = (element.completed === 'true');
                    connection_weights = this.adjustConnectionWeights(element.connection_weights)

                    elem = {
                    id: element.id,
                    name: element.name,
                    user_name: element.user_name,
                    combination_functions:element.combination_functions,
                    connection_weights: connection_weights,
                    in_connection: element.in_connection,
                    init_value: element.init_value,
                    show_param_btn: element.show_param_btn,
                    speed: element.speed,
                    message: element.message,
                    sentiment_lbl: element.sentiment_lbl,
                    completed: completed,
                    observed: false,
                    is_internal:element.is_internal,
                    values:element.values,
                    initial_state: element.initial_state,
                    fout: false
                    }

                    return elem
              }

              elem = {
                    id: '',
                    name: '',
                    user_name: '',
                    combination_functions:[],
                    connection_weights: [],
                    in_connection: [],
                    init_value: 0,
                    show_param_btn: false,
                    speed: 0,
                    message: [],
                    sentiment_lbl: 'Positive',
                    completed: completed,
                    observed: false,
                    is_internal:false,
                    values:[],
                    initial_state:false,
                    fout: false
                }
                return elem
          },






            ////////////////////////END Of ALPINE STRUCTURE/////////////////
            ////////////////////////////////////////////////////////////////
        }))
    })
</script>



{% endblock %}