<!--
This version contains the monitoring of states having monitoringstate = true
and will be showing only the monitoring states
-->
{% extends "base.html" %}

{% block page_content %}

<!--csrftoken is not defined-->
{% csrf_token %}
<script>
const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;
</script>

<p> Model Monitoring</p>
<div x-data="monitoringProgress">


    <!--Base Network Model-->
    <div>
        <template x-for="(progress,pindex) in progressOfNetwork" :key="pindex">
            <div>
                <hr>
                <!--Iteration <span x-text="pindex"></span>-->
                <template x-for="(prg,prgindex) in progress.progress" :key="prgindex">
                    <div  x-data="{curprg: prg, bstate:prg.from, stateclicked: prg.from, istostate:false}">
                        <table>
                            <tr>
                                <td>
                                    <div x-show="true"> <!--"!bstate.isinternal"-->
                                        <button id="bstate.id" x-text="bstate.id + '-' + bstate.complete"  type="button"
                                            @click="console.log('WORKING ON CHANGING THE COLOR AND DATA',bstate.fout);
                                                recordFromAction(curprg)"
                                            class="button button4"
                                            :class="{ 'bg-yellow-300': (bstate.monitoringstate && !bstate.complete),
                                                      'bg-green-500':  (bstate.monitoringstate && bstate.complete),
                                                      'bg-green-300' : (!bstate.monitoringstate && bstate.complete),
                                                      'bg-neutral-300': (!bstate.monitoringstate && !bstate.complete)}">
                                            <!--:disabled="!bstate.monitoringstate">-->
                                        </button>
                                    </div>
                                </td>
                            </tr>
                            <!--<tr>
                                <td>
                                    <div x-show="prg.showNextEntry">
                                        <button x-on:click="showNextEventBasedProgressElement(curprg,stateclicked,istostate)" class="btn btn-success"> Show Next </button>
                                    </div>
                               </td>
                           </tr>-->
                        </table>
                    </div>
                </template>
            </div>
        </template>
    </div>

    <!--Base Network Model-->
</div>


<!--{{ data}}-->


<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('monitoringProgress', () => ({
            id:0, //model id
            name:'',
            stateMatrix:[],

            //base Level Network
            individualBaseLevelOutConnections:[],  //this structure contains all individual outgoing connections without X1->X1. May also have X1-X2;X1->X3
            outgoingBaseLevelNetwork:[],        // this structure contains causal connection X1->X2,X3 and so on
            incomingBaseLevelNetwork:[],        //this structure contains all individual incoming connections
            progressOfNetwork:[],               // this structure contains progress of network
            language:'nl-NL',

            iteration:0,

            // Second Order Adaption
            firstOrderLevel:[],
            secondOrderLevel:[],


            /////////////////////////////////////////////////////////////////
            // Event handlers

            showNextProgressElement(curprg,istostate){
                /* This function is called when user requests to show the next state.
                    it gets the next progress element based upon the clicked state.
                    1. curprg element is shown
                    2. get to elemets of the state, and populate the progress element accordingly
                    2.a. if the state is already in the current progress
                                then dont show but change the values accordingly.
                    2.b. if the element is null then dont show the next state but alert with 'process is completed'
                    2.c. TO-THINK: if state is an internal state, how will it go to the next state?

                    //this.progressOfNetwork[this.iteration] = {progress: progress}
                */

                from_elem = curprg.from
                to_elems = curprg.to
                //if the element is already in  the progress skip it otherwise show

                //console.log('from_elem',from_elem,this.progressOfNetwork)

                if(from_elem.complete)
                {

                    to_elems = this.getToElementsofaState(from_elem,false)
                    //console.log('SHOWNEXT - lastelem', to_elems)

                    //2.a. if the state is already in the current progress then dont show but change the values accordingly.

                    progress = this.progressOfNetwork[this.iteration].progress
                    for(var i = 0; i < to_elems.length;i++){
                        //check from elements
                        fidx = progress.findIndex(e => e.from.id == to_elem.id)
                        if(fidx == -1)
                        {
                            //check to elements
                            tfound = true
                            for(var j = 0; j < progress.length;j ++)
                            {
                                p_to_elems = progress[j].to
                                tidx = p_to_elems.findIndex(e => e.id == to_elem.id)
                                if(tidx == -1)
                                    tfound = false
                                else
                                    if(to_elem.id != '')    //true implies it is at the end of the network
                                        tfound = true

                            }

                            //console.log('tfound',tfound)
                            if(tfound == false)
                            {
                                //place the element in the progress bar
                                to_elems = this.getToElementsofaState(from_elem,true)
                            }
                        }
                    }
                    // calls the statusupdate function to update all the model values
                    this.getStatusUpdate()
                }

            },

            recordFromAction(curprg){
            /*
                    This function is called when a from element is clicked
                    Input: current progress (curprg) and state (bstate)
                    Assumptions: State is not an internal state.
                    Output: 1. State is considered to be completed.
                            2. Show other outgoing states which are not internal
                */

                console.log('current progress,state clicked',curprg);
                from_elem = curprg.from
                //1.a. set the state as completed
                // preliminary checks
                //1.a.a. if the state is already completed
                if(from_elem.complete)
                {
                    console.log('state is already completed')
                    return
                }

                from_elem.complete = true;

                //1.b. update the values of the current state
                this.sendStatusUpdate(from_elem)

                //2. Show other outgoing states which are not internal - also not present before
                this.showNextProgressElement(curprg)

            },

            async getStatusUpdate(){
            /*  This function is called to continously update the values from django view for all the states in the model
            */
                //console.log('TO-DO: get Status Update')
                console.log('TO-DO:progressOfNetwork',typeof(this.progressOfNetwork), this.progressOfNetwork)
                curprg = this.progressOfNetwork[this.iteration].progress



                try {
                    let data_url = './getstatestatus/'  //dont forget the trailing slash
                    response = await axios.get(data_url);
                    progress = response.data.progress;
                    json_prg = JSON.parse(progress).last_progress
                } catch (err) {
                    // Handle Error Here
                    console.error(err);
                }

                //console.log('Before Updation',this.progressOfNetwork[this.iteration].progress, json_prg)
                //console.log('TYPEES',typeof(this.progressOfNetwork[this.iteration].progress), typeof(json_prg))

                json_prg_arr_obj = json_prg[0]; // this have the progress element which is an array

                console.log('Array Obj',json_prg_arr_obj.progress, typeof(json_prg_arr_obj))
                alert('hello')
                this.progressOfNetwork[this.iteration].progress = json_prg_arr_obj.progress




            },




            sendStatusUpdate(state){
            /* This function sends the data to django view to start simulation
               At the same time, it will get the values updated from the simulation results
            */

                values = state.values

                if(state.complete  && values.length == 1)
                {
                    curvalue = 1.0; //state.initvalue;
                    timestamp = this.getTime();
                    value = {curvalue:curvalue, timestamp:timestamp}
                    values.push(value)
                }
                else if(state.complete)
                {
                    curvalue = 8.0; //get the last value from the simulation and then update the values accordingly
                    timestamp = this.getTime();
                    value = {curvalue:curvalue, timestamp:timestamp}
                    values.push(value)
                }

                console.log('values',values)

                axios({
                method: 'post',
                url: '/setstatestatus/',
                data: {
                    id: this.id,
                    name: this.name,
                    last_progress: this.progressOfNetwork
                },
                headers: {//'Content-Type': 'application/json',
                           'X-CSRFToken': csrftoken},
                           validateStatus: (status) => {         //validateStatus
                           return true;
                          },
                })
                .then((response) => {
                    if (response.status == '200')
                    {
                        console.log(response.status);
                    }

                }, (error) => {
                    console.log(error.response.data);
                });
            },

            //////////////////////Supporting Methods

            getTime(){
            //This method returns curr time
                var currentdate = new Date();
                var timestamp = "" + currentdate.getDate() + "/"
                                   + (currentdate.getMonth()+1)  + "/"
                                   + currentdate.getFullYear() + " @ "
                                   + currentdate.getHours() + ":"
                                   + currentdate.getMinutes() + ":"
                                   + currentdate.getSeconds();
                return timestamp
            },

            getToElementsofaState(state, produce = true){
                  /*
                  this function returns the to elements of a state
                  Input: state
                  Output: list of outgoing elements
                  1. get the outgoing elements of a state
                  2 will think. increment the iteration and
                  2. append the outgoing elements in the progress of network
                  */
                //console.log('PRODUCE',produce);
                progress = []
                nextidx = this.outgoingBaseLevelNetwork.findIndex(e => e.from.id === state.id )
                //console.log('state,nextidx',state,nextidx)
                if(nextidx > -1)
                {
                  //1. get the to elements of the 'from' state.
                  //1.a. get the outgoing elements of each of the to states
                  //1.b. append the outgoing elements in the progress of network

                  to_elems =  this.outgoingBaseLevelNetwork[nextidx].to
                  for(let i = 0; i < to_elems.length;i++)
                  {
                    from_state = to_elems[i]
                    idx = this.outgoingBaseLevelNetwork.findIndex(e => e.from.id === from_state.id )
                    //console.log('getToElementsofaState: from_state, idx =',from_state, idx)
                    if(idx > -1)
                    {

                        //create new entry and update its status
                        elem = this.outgoingBaseLevelNetwork[idx]
                        entry = this.createNewEntry(elem)
                        //console.log('entry =',entry,produce,this.iteration)

                        if(produce)
                        {
                            this.progressOfNetwork[this.iteration].progress.push(entry)
                        }
                    }
                    else
                    {
                        //check if this is the last entry then show it as completed
                        if(from_state.id == '')
                        {

                            from = this.createNewElement(from_state)
                            //console.log('LASTTTTTTTTTTTT STATE:', from_state,produce)
                            //if last state is klaar, mark it as completed
                            from.complete = true
                            to = []
                            entry = {
                                from: from,
                                to: to
                            }

                            if(produce)
                                this.progressOfNetwork[this.iteration].progress.push(entry)
                        }
                    }
                  }
                }
              return to_elems
            },

            createNewEntry(curprg){
                /*this function creates an entry with new elements in it.
                This takes an entry having from, to and shownext and showstates parameters
                Target is to keep each state independent*/

                from = this.createNewElement(curprg.from)
                to = this.generateToElements(curprg.to)
                //completed = this.updateStateStatus(from)
                //console.log('completed',completed)

                entry = {
                           from: from,
                           to: to
                       }
               return entry
            },


            /////////////////////////////////////////////////////////////////
            // Initializations

            init(){
                /* Loading the graph from the database*/
                //1. parse json
                 json_data = JSON.parse("{{data|escapejs}}")
                 //console.log(json_data)
                 this.id = this.id
                 this.name = json_data.name
                 specification = json_data.specification

                 baseModel = specification[0]
                 this.incomingFirstOrderLevel = specification[1]
                 this.incomingSecondOrderLevel = specification[2]

                 //2. generating stateMatrix
                 this.stateMatrix.push(specification[0])
                 this.stateMatrix.push(specification[1])
                 this.stateMatrix.push(specification[2])


                 //3. generating model matrix. This matrix consists of outgoing connections
                 //console.log(baseModel)
                 this.generateIncomingBaseLevelNetwork(baseModel)
                 this.generateOutgoingBaseLevelNetwork(baseModel)


                 // 4. initialization of progressOfNetwork
                 this.initializeProgress()
            },//init

            initializeProgress()
            {
                /* This function populates the network to be displayed for the initial states
                    It also allocates the memory for the network
                */

                progress = []
                //populating the network with the initial states
                for (i = 0; i < this.outgoingBaseLevelNetwork.length; i++)
                {
                    curiterEntry = this.outgoingBaseLevelNetwork[i]
                    show = curiterEntry.from.initial_state
                    if(show == true)
                    {
                        entry = this.createNewEntry(curiterEntry)
                        progress.push(entry)
                   }
                }
                this.progressOfNetwork[this.iteration] = {progress: progress}
            },

            generateToElements(toelems){
                /* This function generates new progress Elements from the toelements
                Input: to elements
                Output: the 'to' states of the entry as 'new' elements => allocating new memory
                */

                to = []
                for(var i = 0; i < toelems.length; i++)
                {
                    to_elem = toelems[i]
                    elem = this.createNewElement(to_elem)
                    to.push(elem)
                }
                return to
            },




            //Outgoing Network Model

            generateOutgoingBaseLevelNetwork(model) {
                /*making the outgoing graph from individual incoming connections
                    Input: X1->X2 and X1->X3
                    Output: X1->X2,X3
                    This will populate outgoingBaseLevelNetwork which will have information like 'from' state to 'to' states
                 */

                this.generateIndividualBaseLevelOutConnections(model)

                // get outgoing states for all states in a model

                incomingGraph = []

                for (index = 0; index < this.individualBaseLevelOutConnections.length; index++)
                {
                    //generating from element
                    elem = this.individualBaseLevelOutConnections[index].from
                    //check if from_elem is an initial state
                    initial_state = this.isInitialState(elem)

                    from_elem = this.createNewElement(elem)
                    from_elem.initial_state = initial_state

                    //generating to elements
                    elem = this.individualBaseLevelOutConnections[index].to
                    initial_state = this.isInitialState(elem)
                    to_elem = this.createNewElement(elem)
                    to_elem.initial_state = initial_state
                    //console.log('to_elem', to_elems)

                    to_elems=[]

                    idx = this.outgoingBaseLevelNetwork.findIndex(e => e.from.id === from_elem.id)

                    if(idx == -1)
                    {
                        //element is not found in the outgoingBaseLevelNetwork
                        //check if to_elem is already a from element then create a new element
                        toidx = this.outgoingBaseLevelNetwork.findIndex(e => e.from === to_elem)
                        //console.log('toidx', toidx)

                        if(toidx > -1)
                        {
                            elem = this.outgoingBaseLevelNetwork[toidx].from
                            initial_state = this.isInitialState(elem)
                            to_elem = this.createNewElement(elem)
                            to_elem.initial_state = initial_state
                        }

                        to_elems.push(to_elem)


                        this.outgoingBaseLevelNetwork.push({from: from_elem, to: to_elems})
                    }
                    else
                    {
                        //from state already exists in the network, then append the baseModel
                        this.outgoingBaseLevelNetwork[idx].to.push(to_elem)
                    }
                }
            }, //generateOutgoingBaseLevelNetwork

            generateIndividualBaseLevelOutConnections(model){
            /*  Function to extract the incoming states to make an outgoing graph
                Input: States like X2<-X1; X3<-X1
                Output: X1->X2 and X1->X3
                */

                for(var i = 0; i < model.states.length; i++){
                    state = model.states[i];
                    this.getOutgoingStates(state, model)
                }
           },

           getOutgoingStates(to_state, model){
            /*  Function to extract the incoming states to make an outgoing graph
                Input: States like X2<-X1; X3<-X1
                Output: X1->X2 and X1->X3
            */
                   sid = state.id.toLowerCase()
                   found = false
                   for(i = 0; i< model.states.length;i++)
                   {
                       incoming = model.states[i].inconnection
                       for(j = 0; j < incoming.length;j++)
                       {
                            val = incoming[j].value.toLowerCase()
                            if( val == sid)
                            {
                                found = true
                                ostate = model.states[i]
                                if(ostate != state) //avoiding self-reference
                                {
                                    this.individualBaseLevelOutConnections.push({'from':state, 'to':ostate})
                                }
                            }
                       }
                   }
                   if (!found)
                   {
                      toelem = this.createNewElement() //process completed
                      toelem.name = 'Klaar'
                      toelem.username = 'Klaar'

                      this.individualBaseLevelOutConnections.push({'from':state, 'to':toelem})
                   }
           },

           isInitialState(state)
           {
               //this function check and return if a state is an initial state
               initial = false
               //console.log('state',state)
              // console.log('incomingBaseLevelNetwork',this.incomingBaseLevelNetwork)
               idx = this.incomingBaseLevelNetwork.findIndex(e => e.state.id == state.id)
               if(idx > -1)
               {
                    incoming_elems = this.incomingBaseLevelNetwork[idx].incoming_states
                    //if there is no incoming element
                    if(incoming_elems[0].id == '')
                        return true

                    if (idx == 0)//Assumption: first state is always an initial state
                        initial = true
               }
               return initial
           },


            //Incoming Network Model

            generateIncomingBaseLevelNetwork(model){
                /*  Function to extract the incoming states to make an incoming graph
                Input: States like X1<-X1; X2<-X1
                Output: X1<-null and X2<->X1
                */

                   for(var i = 0; i < model.states.length; i++){
                      state = model.states[i]
                      incoming_states = this.getIncomingStates(state,model)
                      this.incomingBaseLevelNetwork.push({state: state, incoming_states: incoming_states})
                   }
            },

            getIncomingStates(states,model){
                   /*   Function to extract the incoming states to make an incoming graph
                        Input: States like X2<-X1; X1<-X1
                        Output: X2->X1 and X1->0
                   */

                   sid = state.id.toLowerCase()

                   found = false
                   idx = model.states.findIndex(e => e.id.toLowerCase() == sid)
                   incoming = model.states[idx].inconnection
                   //iterate the incoming states data structure
                   incoming_states = []
                   for(var i = 0; i < incoming.length; i++){
                        conn_value = incoming[i].value.toLowerCase()
                        if(conn_value != sid) //avoiding self reference
                        {
                            found = true
                            incoming_stateidx = model.states.findIndex(e => e.id.toLowerCase() == conn_value)
                            incoming_state = model.states[incoming_stateidx]
                            incoming_states.push(incoming_state)
                        }
                   }

                   if(!found)
                   {
                     null_state = this.createNewElement()
                      incoming_states.push(null_state)
                   }

                   return incoming_states
          },

          //Creating a new element, to avoid replicas
          createNewElement(element){
              if(element)
              {
                    //convert strings if any to boolean
                    var complete = (element.complete === 'true');
                    isinternal = false
                    if(element.isinternal == 'true' || element.isinternal == true)
                        isinternal = true

                    elem = {
                    id: element.id,
                    name: element.name,
                    username: element.username,
                    combinationfunctions:element.combinationfunctions,
                    connectionweights: element.connectionweights,
                    inconnection: element.inconnection,
                    initvalue: element.initvalue,
                    showParamBtn: element.showParamBtn,
                    speed: element.speed,
                    message: element.message,
                    sentimentlbl: element.sentimentlbl,
                    complete: complete,
                    isinternal:element.isinternal,
                    values:element.values,
                    initial_state: element.initial_state,
                    fout: false
                    }

                    return elem
              }

              elem = {
                    id: '',
                    name: '',
                    username: '',
                    combinationfunctions:[],
                    connectionweights: [],
                    inconnection: [],
                    initvalue: 0,
                    showParamBtn: false,
                    speed: 0,
                    message: [],
                    sentimentlbl: 'Positive',
                    complete:false,
                    isinternal:false,
                    values:[],
                    initial_state:false,
                    fout: false
                }
                return elem
          },






            ////////////////////////END Of ALPINE STRUCTURE/////////////////
            ////////////////////////////////////////////////////////////////
        }))
    })
</script>



{% endblock %}